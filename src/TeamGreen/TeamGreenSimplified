/*
Line Following Base Code with Four Sensors
Digital Inputs should be 4-7, Right to Left
From the POV of the Bot
*/


#define IRR 4               // pin for the right most QTI  (facing the front of the bot)        
#define IRRC 5              // pin for the center right QTI   
#define IRLC 6              // pin for the center left QTI
#define IRL 7               // pin for the left most QTI 

#define LED 3               // pin for the LED Indicator 

#include <Servo.h>           
#include <SoftwareSerial.h> 
#define onesens 8           // pin for the sensing QTI on the side
 
#define Rx 11 // DOUT to pin 11  // pin for Xbee output
#define Tx 10 // DIN to pin 10   // pin for Xbee input
SoftwareSerial Xbee (Rx, Tx);


Servo leftServo;                //define servos 
Servo rightServo;               
int calibDiff = 50;            // cutoff RC time value for detecting black line on the board
int calibsen = 400;            // cutoff RC time value for detecting the peg on the side
int counter = 0;               // stores the distance between the pegs
int contact = 2;               // number of pegs needed to be detected
int accu = 15;                 // RC time value needed to be greater than cutoff value 15 times consectively to ensure a peg is detected
int c0 = 0;                    // base value distance
int c1 = 100;                  // distance value ceiling for reporting a '1'
int c2 = 200;                  // distance value ceiling for reporting a '2'
int c3 = 300;                  // distance value ceiling for reporting a '3'
int c4 = 430;                  // distance value ceiling for reporting a '4'
int c5 = 1000;                 // distance value ceiling for reporting a '5' 
int report = 0;                // the result 
int black = 0;                 // used as a boolean, to indicator whether a black tick mark is reached or not
int tick = 0;                  // number of tick mark passed
int des = 0;                   // the parking tick mark 

void setup() 
{
  Serial.begin(9600);
  leftServo.attach(13);        //attach servos
  rightServo.attach(12);
  Move(0,0);
  pinMode(LED,OUTPUT);
  
   // XBee setup: 
 Xbee.begin(9600);
 delay(3000);
}


void Move(int left, int right) {
  delay(0);
 if (left == 1) {
 leftServo.writeMicroseconds(1600);
 } else if (left == 0) {
   leftServo.writeMicroseconds(1500);
 }
 if (right == 1) {
 rightServo.writeMicroseconds(1425);
 } else if (right == 0) {
   rightServo.writeMicroseconds(1500);
}
}  
long RCtime(int sensPin){
   long result = 0;
   pinMode(sensPin, OUTPUT);       // make pin OUTPUT
   digitalWrite(sensPin, HIGH);    // make pin HIGH to discharge capacitor - study the schematic
   delay(1);                       // wait a  ms to make sure cap is discharged
   pinMode(3,OUTPUT);

   pinMode(sensPin, INPUT);        // turn pin into an input and time till pin goes low
   digitalWrite(sensPin, LOW);     // turn pullups off - or it won't work
   while(digitalRead(sensPin)){    // wait for pin to go low
      result++;
   }


   return result;                   // report results   
} 


int PegValue(int counting){
  int Peg = 0;
  if (counting >=c0 && counting <=c1){
  Peg = 1;
  }
  
  if (counting >c1 && counting <=c2){
  Peg = 2;
  }
  
  if (counting >c2 && counting <=c3){
  Peg = 3;
  }
  
  if (counting >c3 && counting <=c4){
  Peg = 4;
  }
  
  if (counting >c4 && counting <=c5){
  Peg = 5;
  }
  
  return Peg;
}
void onBlack(){
  des = 6-report; 
  if(black==0 && tick!=des){
    Move(0,0);
    tick++;
    if (tick ==1)  {
      Move(0,0);
      leftServo.detach(); //attach servos
      rightServo.detach();
      for (int k =0;k<report;k++) {
        digitalWrite(LED, HIGH);          // Pin 13 = 5 V, LED emits light
        delay(300);                      // ..for 0.5 seconds
        digitalWrite(LED, LOW);           // Pin 13 = 0 V, LED no light
        delay(300);  
      }
      //report = doIGo();
      waitForSignal(report);
      leftServo.attach(13); //attach servos
      rightServo.attach(12);
      delay(200);
    }
    black = 1; 
    
  } else if (black == 1){
    Move(1,1);
  } else if(tick == des){
  Move(0,0);
  imGoing(report);
  leftServo.detach(); //attach servos
  rightServo.detach();
  while(1) {
    delay(1000);
  }
  }
}
void loop() {
  int irl = RCtime(IRL) > calibDiff;
  int irlc = RCtime(IRLC) > calibDiff;
  int irrc = RCtime(IRRC) > calibDiff;
  int irr = RCtime(IRR) > calibDiff;
  int Answer;
  
  if (irl && irlc && irrc && irr) {
    // All Black
    onBlack();
    //Serial.println(tick);
  } 
  else if (irlc && irrc) {
    // Insides Black
    Move(1,1);
  } else if (!irr && !irrc) {
    // Two Right Sides white
    Move(0,1);
  } else if (!irl && !irlc) {
    // Two Left Sides white
    Move(1,0);
  }
  if (!irr && !irl){
    black = 0; 
  }
  
  
  int d1 = RCtime(onesens) > calibsen;
  //int d2 = RCtime(twosens) > calibsen;
  if (!d1 && contact==2){
    accu--;
    if (accu==0){
      contact--;
      accu=15; 
    } 
  }
  if (d1 && contact==1 && counter>=0){ 
    counter++; 
    //Serial.println(counter); 
  }
  if (!d1 && contact==1 && counter>15){ 
    accu--;
    if (accu==0){
      contact--;
      report = PegValue(counter);
    }      
  }
}


//This function will wait until your bot recieves a message to go. (The bot in front of you in line should 
//send this mesage.) There is a timeout that corresponds to your bot number. There is a grand timeout of 45s.
//If you send -1, your bot will go at 45 seconds.
void waitForSignal(int pos) {
   long now = millis();
   while(1) {
     //if i'm bot 1, I go
     if (pos == 1) {
       //time to go!
       return; 
     }
     
     //the values
     char keymap[] =  "yuiop";
     char theirKey = keymap[pos-1];
    
     //read xbee until the person in front of you says going
     while (Xbee.available()) {
      //Read Character
      char receiving = Xbee.read();
      //if char is the id of the bot in front of me, I should go
      if (receiving == theirKey) {
       //my turn
       return; 
      }
    }
    
    //unknown value? send -1 and wait for 45. TODO: deduce position
    if (pos == -1) {
       delay(45000L); //30 seconds before going
    }
    
    //time out
    if (millis() > (30000L + ((long)pos)*10000L)) {
        return;
    }
    
    //grand timeout
    if (millis() > 90000L) {
       return; 
    }
  }
}

void imGoing(int pos) {
   char keymap[] =  "yuiop";
   for (int i = 0; i < 10; i++) {
     Xbee.print(keymap[pos]);
     delay(10);
   }
}
